\documentclass[oneside]{memoir}

\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[spanish,activeacute]{babel}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage[document]{ragged2e}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}

%Opciones para el formato de los listing
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}


\title{YourPlacesBot - A Telegram Bot}
\author{David Quesada L\'opez y Mateo Garc\'ia Fuentes}

\setlength{\parskip}{1em}

\newcommand{\romanpages}{
\pagenumbering{roman}
\thispagestyle{empty}
\beforepartskip
\centering

\thetitle

\theauthor

GRADO EN INGENIER\'IA INFORM\'ATICA 

FACULTAD DE INGENIER\'IA INFORM\'ATICA

UNIVERSIDAD COMPLUTENSE DE MADRID

\includegraphics{logo.jpg}

TRABAJO DE FIN DE GRADO EN INGENIER\'IA INFORM\'ATICA

Director: Carlos Gregorio Rodríguez

\today
\afterpartskip
\newpage

\thispagestyle{empty}
%\beforepartskip
\raggedright

\begin{center}
  \makebox{\includegraphics[width=\textwidth]{autoriz.png}}
\end{center}

\afterpartskip
\newpage
\thispagestyle{empty}
\raggedright

\textbf{Agradecimientos}

Gracias a Nick Lee (https://github.com/nickoala) por desarrollar telepot, un framework de Python para API de Telegram Bot y desarrollarlo bajo una licencia MIT.

\afterpartskip
\newpage
}

\newcommand{\indexpage}{
\begin{KeepFromToc}
 \frontmatter
 \setcounter{page}{4}
 \pagestyle{plain}

 \tableofcontents

 \newpage
\end{KeepFromToc}
}

\newcommand{\mychapter}[2]{
    \setcounter{chapter}{#1}
    \setcounter{section}{0}
    \chapter*{#2}
    \addcontentsline{toc}{chapter}{#2}
}


\begin{document}

\romanpages
\indexpage
\mainmatter
\pagenumbering{roman}
\pagestyle{plain}
\raggedright
\newpage
\setcounter{page}{5}
\mychapter{0}{\'Indice de figuras}

\newpage
\mychapter{0}{\'Indice de abreviaturas}

\newpage
\mychapter{0}{Resumen}
Una de los principales atractivos de Telegram es su plataforma para bots. Los usuarios pueden crear sus propios bots y ponerlos en funcionamiento para que sean accesibles a todos los clientes de Telegram sin coste alguno para el desarrollador o para el consumidor. Estos bots proporcionan en su mayoría información, juegos o utilidades dentro de un chat, y aumentan en gran medida la funcionalidad de Telegram.

A la hora de que un usuario interactúe con un bot, es especialmente interesante que el servicio que se le preste pueda depender de su ubicación geográfica y pueda tener un componente social. Por ello, este proyecto tiene como objetivo informar al usuario sobre qué establecimientos cercanos hay en base a su localización, ofreciendo la posibilidad de encontrarlos fácilmente y de ver datos proporcionados por otros usuarios sobre estos.

Palabras clave: bot, Telegram, geolocalización, noSQL, mapas de calor.

\newpage
\mychapter{0}{Abstract}
One of the main features of Telegram is its bot support. Users can create their own bots and launch them to be available for everyone in Telegram without cost for neither the developer nor the client. These bots mainly offer information, games or utilities inside the chat and they increase greatly Telegrams functionality.

When an user interacts with a bot, it is of special interest that the response of the bot varies depending on the users location and on a social component. That's why this project aims to inform the user about what near by establishments there are depending on his location, offering the posibility to find them easily and to see information of them given by other users.

Keywords: bot, Telegram, geolocation, noSQL, heatmaps.

\newpage
\pagenumbering{arabic}

\mychapter{1}{Cap\'itulo 1: Introducci\'on}
\section{Motivaci\'on}
La motivación para crear este bot surgió a partir de unas conversaciones con amigos. Se quejaban de no disponer de una herramienta sencilla para poder ver qué locales hay cercanos a nosotros y así elegir a dónde ir si no conoces el lugar. 

Al intentar buscar una solución a este problema lo primero en lo que pensamos fue la aplicación de Google Maps. Google Maps tiene la funcionalidad de encontrar establecimientos cercanos a ti en base a tu localización y a qué buscas, pero el resultado fue que la aplicación es demasiado grande y no es práctico tener que abrirla, navegar entre todas las opciones y funcionalidades que ofrece y ponerte a buscar un local que te guste. %En la práctica, Google Maps lo usas en la mayoría de casos embebido en otras aplicaciones que luego te redirigen a él para una funcionalidad en concreto, como la ubicación de Telegram.

En esta situación, pensamos que un bot de Telegram encajaría bien como solución. Por un lado, Telegram es una aplicación que usamos día a día y un bot resultaría fácil de manejar. Por otro lado, la función de compartir la ubicación de Telegram se adecúa perfectamente a la API de Google Maps para realizar consultas de búsqueda de establecimientos cercanos.

\section{Objetivos}
El objetivo de este proyecto será la implementación de un bot de Telegram que resuelva el problema expuesto anteriormente valiéndose de la ubicación que se le envíe para devolver locales con las características indicadas. Para esto, vamos a establecer una serie de objetivos que el bot debe cumplir:

\begin{itemize}
  \item Ser capaz de \textbf{recibir una localización y devolver una lista de locales cercanos a ella}. Estos locales deberán estar dentro de un cierto radio de distancia variable y por defecto se buscará que estén abiertos en el instante de la búsqueda.
  \item Cuando se seleccione un establecimiento, \textbf{se devolverá su ubicación} y la información de la que disponga el bot sobre él.
  \item Poderle dar una puntuación a los establecimientos y ser capaz de enviar fotografías al bot.
  \item Poder mostrar un \textbf{mapa de calor} en torno a tu localización reflejando las ubicaciones más concurridas por otros usuarios
\end{itemize}


\section{Estructura del documento}
Vamos a estructurar este documento conforme al orden en el que fuímos desarrollando el bot. Para cada versión con nuevas funcionalidades, documentaremos qué hemos cambiado, cómo lo hemos hecho y a qué problemas nos hemos enfrentado.

A continuación mostramos sobre qué va a tratar cada capítulo:

\begin{itemize}
  \item \textbf{Capítulo 2: Infraestructura para bots - Telepot}. En este capítulo introduciremos al lector al desarrollo de bots en Telegram contando cómo es la infraestructura que tienen y la API que ofrece Telegram a los desarrolladores. También hablaremos de qué es y por qué hemos usado el framework de Telepot para nuestro bot en vez de la API nativa de Telegram.
  \item \textbf{Capítulo 3: Experimentación previa}. Esta parte tratará de nuestro primer acercamiento a la creación de bots. Hablamos de cómo empezamos a usar Telepot para codificar bots simples y lo que aprendimos para usar en un futuro en nuestro bot final.
  \item \textbf{Capítulo 4: Primera versión - Establecimientos cercanos}. En este apartado hablamos sobre el desarrollo de la primera versión estable de YourPlacesBot. Esta versión ya cuenta con la funcionalidad y la interfaz básicas y sirve como base sobre la que poder ir implementando mejoras. % Versión que sólo devolvía la localización de los establecimientos. Hasta el "Here it is!" sin ninguna opción.
  \item \textbf{Capítulo 5: Segunda versión - Base de datos e interacción}. Aquí tratamos el desarrollo de la versión que ya era capaz de realizar toda la interacción entre el bot y el usuario. Es la primera versión que pusimos a funcionar de manera continuada en Telegram.
  
  \item \textbf{Capítulo 6: Tercera versión - Opciones y Heatmaps}. Este apartado trata sobre la última versión del bot, donde se introducen opciones sobre el funcionamiento del bot que cada usuario puede variar y mapas de calor en base a tu ubicación.
  
  \item \textbf{Capítulo 7: Conclusiones y trabajo futuro}. En este último capítulo sacamos conclusiones sobre el desarrollo del bot en Telegram y exponemos las mejoras futuras a implementar en el bot.
\end{itemize}

\newpage
\mychapter{2}{Cap\'itulo 2: Infraestructura para bots - Telepot}
%En este capítulo introduciremos al lector al desarrollo de bots en Telegram contando cómo es la infraestructura que tienen y la API que ofrece Telegram a los desarrolladores. También hablaremos de qué es y por qué hemos usado el framework de Telepot para nuestro bot en vez de la API nativa de Telegram.
\section{Plataforma de bots de Telegram}
El servicio de mensajería Telegram Messenger ofrece una interfaz de programación para bots, llamada Telegram Bot API. Estos bots son aplicaciones de terceros que se ejecutan en Telegram. La forma de interactuar con estos bots es muy variada: mensajes, comandos, archivos, botones, etc. Las características usuales de estos bots son proporcionar notificaciones y noticias personalizadas, juegos o integración de servicios externos a Telegram.

Los mensajes, comandos y peticiones enviados por los usuarios se envían al software que se ejecuta en los servidores. Los servidores de Telegram, que son intermediarios entre nuestro servidor y el usuario, manejan el cifrado y la comunicación. Esta comunicación se realiza a través de una interfaz HTTPS que ofrece una versión simplificada de la API de Telegram. 

Los desarrolladores deben crear sus bots a través de @BotFather. Este bot es el padre de todos los bots y proporciona tokens únicos para cada uno. También es necesario para administrar los bots y gestionar sus configuraciones. Además de esto, el @BotFather avisa a los desarrolladores de bots populares (300 solicitudes por minuto o más) si detecta que la tasa de conversión de solicitud/respuesta es muy baja. Está alerta consta de 3 botones de respuesta: Arreglado, Silenciar y Apoyo. Esta última opción abrira un nuevo chat con el @BotSupport que ayudará al desarrollador a detectar el problema o averiguar si hay algún problema en los servidores de Telegram.

\section{Telepot}
Telepot es un framework desarrollado por Nick Lee (https://github.com/nickoala/telepot) que te ayuda a desarrollar bots de Telegram usando Python en vez de HTTPS. La funcionalidad básica de Telepot consiste en servir de wrapper de todas las funciones de la API de Telegram para así poder programar el código de los bots en Python.

Además de esto, también ofrece funcionalidades para hacer más cómoda la gestión de servidor de tu bot. Cuando creas un bot, tienes que ir pidiendo a los servidores de Telegram \textit{updates} para que te envíen una lista con los mensajes que le han sido enviados. Telepot te proporciona métodos para que no tengas que preocuparte de montar toda una estructura que gestione su recepción. Telepot se encarga de crear hilos de ejecución por cada chat nuevo que se abre con el bot y de pararlos cuando estos llevan demasiado tiempo sin realizar ninguna tarea. 

\newpage
\mychapter{3}{Cap\'itulo 3: Experimentaci\'on previa}
De cara a afrontar este proyecto, nos encontramos con que debíamos aprender a hacer un bot sin tener conocimientos previos ni de la API de Telegram ni de Python. Por tanto, para coger soltura con el lenguaje y con el funcionamiento de los bots dedicamos la primera parte del proyecto a crear bots que realizasen tareas sencillas. Para crear estos bots, fuímos guiándonos del tutorial a base de ejemplos de Telepot (\url{http://telepot.readthedocs.io/en/latest/}).

\section{Creación de los bots}
El primer paso básico para crear un bot es hablar con @BotFather para crear tu bot con un nombre y que te envíe el token de tu bot. Este token es necesario para poder pedirle al servidor de Telegram las updates de tu bot. 

\begin{figure}[h!]
\centering
\includegraphics[height=75mm]{tokenBotFather.jpg}
\caption{@BotFather provee los TOKEN}
\label{fig:tokenBotFather}
\end{figure}

Una vez obtenido el token, hay que crear un objeto Bot con el framework de Telepot para obtener de manera periódica las updates de nuestro bot. Este proceso sería:

\lstinputlisting[language=Python, firstline=58, lastline=61]{Samples/pairingBot.py}

La clase Bot de Telepot es el wrapper principal de las funciones en HTTPS de la API de Telegram a Python. Llamando al método de message\_loop conseguimos que todos los updates nuevos los trate la función que le indiquemos por argumento, en este caso \textit{on\_chat\_message(msg)}.

Todos los mensajes que maneja el bot tienen formato JSON. Estos mensajes se envían primero a los servidores de Telegram, y son ellos los que se encargan de redirigirlos a su destino. Cuando el bot recibe los mensajes, se puede emplear la función \textit{telepot.glance(msg)} para saber qué contiene (texto, imágenes, audio,...), en qué tipo de chat se ha enviado (grupo o privado) y el id de la persona que lo envió. También se puede acceder a esta información accediendo directamente al JSON del mensaje.
\lstinputlisting[language=Python, firstline=44, lastline=53, title=Ejemplo de un on\_chat\_message]{Samples/pairingBot.py}

\section{Teclados personalizados}
En estos primeros bots también experimentamos con los distintos tipos de teclado que ofrece la API de Telegram, los ReplyKeyboardMarkups y los InlineKeyboardMarkups. La diferencia básica entre estos dos teclados es la posición que ocupan en la pantalla. El primero se sitúa fuera del propio chat sitúandose en el lugar que le correpondería al teclado QWERTY y el segundo está dentro de la propia conversación obligatoriamente acompañado de un mensaje de texto. Otra diferencia es la manera de procesar las pulsaciones, mientras las pulsaciones a los botones de los ReplyKeyboardMarkups se escriben automáticamente en el chat como mensaje del usuario, las pulsaciones de los botones de los InlineKeyboardMarkups se procesan internamente, cada vez que se pulsa uno de estos botones se crea una clase ButtonHandler. 

\begin{figure}[h!]
\centering
\begin{minipage}{7cm}
  \centering
  \includegraphics[height=40mm]{replyKB.jpg}
  \caption{ReplyKeyboardMarkup}
  \label{fig:ReplyKeyboardMarkup}
\end{minipage}%
\begin{minipage}{7cm}
  \centering
  \includegraphics[height=40mm]{inlineKB.jpg}
  \caption{InlineKeyboardMarkup}
  \label{fig:InlineKeyboardMarkups}
\end{minipage}
\end{figure}

\section{Gestión de mensajes - DelegatorBot y handlers}
Lo último con lo que hicimos pruebas en esta primera fase fue con la gestión del servidor. En un principio, nuestros bots procesaban los updates que les llegaban de manera secuencial. Cuando ya empezaron a realizar tareas más complejas, tuvimos que crear servidores simples que lanzasen un hilo por cada nuevo \textit{chat\_id} que les llegase en un mensaje. Así, el bot disponía de un diccionario con los chat\_id y una cola, para que cada mensaje proveniente de un chat\_id ya conocido se encolase para su hilo correspondiente.
\lstinputlisting[language=Python, firstline=82, lastline=87, title=Ejemplo de gestión de mensajes nuevos]{Samples/espiaBot.py}
Tras crear algunos bots que utilizaban este sistema de servidor con hilos por paso de mensajes, nos dimos cuenta de que Telepot proporciona una clase para gestionar todo esto de manera cómoda: la clase \textbf{DelegatorBot} y los \textbf{handlers}. Esta clase tiene la particularidad de que el objeto bot que creas trata de manera diferente los updates que le llegan dependiendo del tipo que sean. Además, este objeto se encarga de lanzar hilos por cada nuevo chat\_id que le llega y los tiene todos registrados por debajo en un diccionario, para poder redirigirles los mensajes que les correspondan a cada uno y poder cerrarlos cuando sea necesario.
\lstinputlisting[language=Python, firstline=323, lastline=330, title=Ejemplo de creación de un DelegatorBot]{../socialBot.py}
Para gestionar cada mensaje de una forma u otra es necesario definir un handler del tipo que corresponda: para gestionar lo relacionado con mensajes en un chat se necesita un ChatHandler y para tratar las pulsaciones en teclados inline se necesita un CallbackQueryOriginHandler. Una vez creadas las clases de los handlers, debe ponerse un pave\_event\_space() por cada tipo de updates diferentes que vaya a tratarse. En los argumentos de esta función se especifica qué evento genera un nuevo hilo, en el caso de ejemplo serían \textit{per\_chat\_id()} para el ChatHandler y \textit{per\_callback\_query\_origin()} para las pulsaciones en los teclados inline. 

El uso del DelegatorBot y los handlers facilita en gran medida la creación de bots más complejos. Una vez que te acomodas a los diferentes eventos de creación de hilos y de handlers que te ofrece Telepot, te ahorra el tener que gestionar tú los hilos y los mensajes, siempre y cuando comprendas bien la gestión interna de estos hilos por parte del DelegatorBot.

\newpage
\mychapter{4}{Cap\'itulo 4: Primera versi\'on - Establecimientos cercanos}

\newpage
\mychapter{5}{Cap\'itulo 5: Segunda versi\'on - Base de datos e interacci\'on}

\newpage
\mychapter{6}{Cap\'itulo 6: Tercera versi\'on - Opciones y Heatmaps}

\newpage
\mychapter{7}{Cap\'itulo 7: Conclusiones y trabajo futuro}

\newpage
\mychapter{0}{Ap\'endice}

\newpage
\begin{thebibliography}{}
%Falta escribirlo en formato IEEE
\bibitem
*LaTex -> http://texdoc.net/texmf-dist/doc/latex/memoir/memman.pdf 
\bibitem
*Python -> https://docs.python.org/2.7/
\bibitem
*API Google Maps Docs -> http://googlemaps.github.io/google-maps-services-python/docs/2.4.5/
\bibitem
*Telegram Bots -> https://core.telegram.org/bots/api
\bibitem
*API Telepot -> http://telepot.readthedocs.io/en/latest/
\end{thebibliography}

\newpage
\mychapter{0}{Anexo}

\newpage
\mychapter{0}{Glosario}

\end{document}