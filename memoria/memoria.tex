\documentclass[oneside]{memoir}

\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[spanish,activeacute]{babel}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage[document]{ragged2e}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}

%Opciones para el formato de los listing
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}


\title{YourPlacesBot - A Telegram Bot}
\author{David Quesada L\'opez y Mateo Garc\'ia Fuentes}

\setlength{\parskip}{1em}

\newcommand{\romanpages}{
\pagenumbering{roman}
\thispagestyle{empty}
\beforepartskip
\centering

\thetitle

\theauthor

GRADO EN INGENIER\'IA INFORM\'ATICA 

FACULTAD DE INFORM\'ATICA

UNIVERSIDAD COMPLUTENSE DE MADRID

\includegraphics{logo.jpg}

TRABAJO DE FIN DE GRADO EN INGENIER\'IA INFORM\'ATICA

Director: Carlos Gregorio Rodríguez

\today
\afterpartskip
\newpage

\thispagestyle{empty}
%\beforepartskip
\raggedright

\begin{center}
  \makebox{\includegraphics[width=\textwidth]{autoriz.png}}
\end{center}

\afterpartskip
\newpage
\thispagestyle{empty}
\raggedright

\textbf{Agradecimientos}

Gracias a Nick Lee (https://github.com/nickoala) por desarrollar telepot, un framework de Python para API de Telegram Bot y desarrollarlo bajo una licencia MIT.

\afterpartskip
\newpage
}

\newcommand{\indexpage}{
\begin{KeepFromToc}
 \frontmatter
 \setcounter{page}{4}
 \pagestyle{plain}

 \tableofcontents

 \newpage
\end{KeepFromToc}
}

\newcommand{\mychapter}[2]{
    \setcounter{chapter}{#1}
    \setcounter{section}{0}
    \chapter*{#2}
    \addcontentsline{toc}{chapter}{#2}
}


\begin{document}

\romanpages
\indexpage
\mainmatter
\pagenumbering{roman}
\pagestyle{plain}
\justify
\setlength{\parindent}{0pt} %Le he quitado la sangría al documento, ¿ponía que o líneas de separación entre párrafos o sangría, pero las 2 no, no?
\newpage
\setcounter{page}{5}
\listoffigures
\newpage
\mychapter{0}{\'Indice de abreviaturas}{
\begin{itemize}
\item \textbf{API:} del inglés \textit{Application Programming Interface}, es una interfaz de programación de aplicaciones. Es una definición de los servicios (funciones/funcionalidades) que un determinado módulo software provee a otros módulos.
\item \textbf{ESRI:} del inglés \textit{Environmental Systems Research Institute}, es un proveedor de software de sistemas de información geográfica (GIS), aplicaciones web de GIS y aplicaciones de gestión de bases de datos geográficas.
\item \textbf{GPS:} del inglés \textit{Global Positioning System}, es un sistema de posicionamiento a nivel global que permite determinar la posición de un objeto en nuestro planeta.
\item \textbf{HTTPS:} del inglés \textit{Hypertext Transfer Protocol Secure}, es un protocolo seguro de transferencia de hipertexto. Consiste en la comunicación a través de HTTP (Hypertext Transfer Protocol) dentro de una conexión cifrada que asegura la autenticación del sitio web visitado y la protección de la privacidad e integridad de los datos intercambiados.
\item \textbf{JSON:} del inglés \textit{JavaScript Object Notation}, es un formato de archivo que utiliza texto legible para humanos para transmitir objetos de datos.
\item \textbf{OTAN:} del francés \textit{Organisation du Traité de l'Atlantique Nord}, es una alianza militar entre 28 estados de Europa y Norteamérica.
\item \textbf{QWERTY:} es una distribución de teclado. Su nombre proviene de las primeras seis letras de su fila superior de teclas. Es la distribución más común aunque en algunos países europeos tienen ligeras modificaciones.
\item \textbf{SQL:} del inglés \textit{Structured Query Language}, es un lenguaje de consulta estructurada. Es un lenguaje diseñado para gestionar datos contenidos en un sistema de gestión de bases de datos relacionales.
\end{itemize}
}

\newpage
\mychapter{0}{Resumen}
Telegram es una aplicación de mensajería instantánea móvil y de escritorio basada en la nube. Esta aplicación, como la mayor parte de las aplicaciones de mensajería instantánea, permite intercambiar mensajes y archivos de todo tipo. En 2016 conseguía llegar a los 100 millones de usuarios y sus servidores procesaban 15 mil millones de mensajes al día.

Una de los principales atractivos de Telegram es su plataforma para bots. Los usuarios pueden crear sus propios bots y ponerlos en funcionamiento para que sean accesibles a todos los clientes de Telegram sin coste alguno para el desarrollador o para el consumidor. Estos bots proporcionan en su mayoría información, juegos o utilidades dentro de un chat, y aumentan en gran medida la funcionalidad de Telegram. 

%Puesto algo sobre asistentes virtuales. No creo que haya que poner mucho más en el resumen, va a pasar de una página si no.
Gracias a esto, hoy en día Telegram no se limita sólo a la mensajería instantánea, sino que también actúa como un asistente personal virtual. Los asistentes virtuales son una característica fundamental en dispositivos móviles, facilitando el día a día de los usuarios y ofreciéndoles información que les es relevante en cualquier momento que lo necesiten. Los bots de Telegram le hacen especialmente potente en este ámbito, ya que continuamente aparecen bots que dotan a Telegram de nuevas capacidades como asistente personal.

A la hora de que un usuario interactúe con un bot, es especialmente interesante que el servicio que se le preste pueda depender de su ubicación geográfica y pueda tener un componente social. Por ello, este proyecto tiene como objetivo informar al usuario sobre qué establecimientos cercanos hay en base a su localización, ofreciendo la posibilidad de encontrarlos fácilmente y de ver datos proporcionados por otros usuarios sobre estos.
\bigbreak
{\Large\textbf{Palabras clave:} bot, Telegram, geolocalización, noSQL, mapas de calor.}

\newpage
\mychapter{0}{Abstract}
Telegram is a cloud-based mobile and desktop instant messaging application. This application, like most instant messaging applications, allows you to exchange messages and files of all kinds. By 2016 it managed to reach 100 million users and their servers processed 15 billion messages a day. %los billones ingleses no van como los billones españoles, 1 billon inglés = 1000 millones españoles

One of the main features of Telegram is its bot support. Users can create their own bots and launch them to be available for everyone in Telegram without cost for neither the developer nor the client. These bots mainly offer information, games or utilities inside the chat and they increase greatly Telegrams functionality.

This opens the path for Telegram to act not only as an instant messaging application, but also as a virtual personal assistant. Virtual assistants are a vital feature of mobile dispositives, making the user's everyday life easier and offering them relevant information at any time they need it. Telegram bots make it especially powerful in this ambit, given that there are bots constantly being created that offer new personal assistant capabilities.

When an user interacts with a bot, it is of special interest that the response of the bot varies depending on the users location and on a social component. That's why this project aims to inform the user about what near by establishments there are depending on his location, offering the posibility to find them easily and to see information of them given by other users.

\bigbreak
{\Large\textbf{Keywords:} bot, Telegram, geolocation, noSQL, heatmaps.}

\newpage
\pagenumbering{arabic}

\mychapter{1}{Cap\'itulo 1: Introducci\'on}
\section{Motivaci\'on}
Si hacemos un análisis de la sociedad actual es fácil observar que el uso de dispositivos móviles es una constante en el día a día de cada persona. Y que la funcionalidad que ofrecen estos aumenta a una gran velocidad. Estos dispositivos son ya una parte esencial de nuestras vidas, y como consecuencia sus aplicaciones también.

Una de las fortalezas de estos dispositivos es la ayuda que nos ofrecen para procesar toda la información que hay en la red. Las aplicaciones con toda esa información nos ayudan a ampliar nuestra percepción del mundo y a tomar decisiones. Otra de las bazas importantes de las nuevas tecnologías son el carácter social que están adquiriendo, con recomendaciones, fotos, \textit{likes} ... Dentro de estas aplicaciones sociales las de mayor uso son las de mensajería instantánea que nos ponen en contacto con nuestros amigos y conocidos, y nos permiten compartir todo tipo de información.

En algunas de las conversaciones con nuestros amigos había quejas de no disponer de una herramienta sencilla y amigable para encontrar bares, restaurantes y otros tipos de locales de ocio cercanos. En lo primero que piensas para buscar una solución a este problema es en la aplicación de Google Maps. Pero esta aplicación no es cómoda sino está embebida en otra aplicación debido a la enorme cantidad de información que ofrece.

En esta situación, pensamos que un bot de Telegram encajaría bien como solución. Por un lado, Telegram es una aplicación que usamos día a día y un bot resultaría fácil de manejar. Por otro lado, su carácter social nos permite tener un \textit{feedback} con los usuarios que nos permita establecer cuales son las mejores opciones que nos ofrece Google Maps.

%Por otro lado, la función de compartir la ubicación de Telegram se adecúa perfectamente a la API de Google Maps para realizar consultas de búsqueda de establecimientos cercanos.

%Google Maps tiene la funcionalidad de encontrar establecimientos cercanos a ti en base a tu localización y a qué buscas, pero el resultado fue que la aplicación es demasiado grande y no es práctico tener que abrirla, navegar entre todas las opciones y funcionalidades que ofrece y ponerte a buscar un local que te guste. %En la práctica, Google Maps lo usas en la mayoría de casos embebido en otras aplicaciones que luego te redirigen a él para una funcionalidad en concreto, como la ubicación de Telegram.

\section{Objetivos}
Al empezar este proyecto, la idea principal era aprender a hacer un bot de Telegram partiendo de los conocimientos previos adquiridos durante la carrera. Para esto, también teníamos como objetivo mejorar nuestra habilidad con Python, que no es un lenguaje que se use ampliamente durante el grado, y con bases de datos no SQL, en este caso MongoDB que se usa en alguna asignatura. Otro punto importante era ser capaces de buscar e integrar APIs que nos resultasen útiles para nuestro bot. Finalmente, también queríamos coger soltura escribiendo memorias de esta extensión utilizando LateX, que no es algo que se practique antes del trabajo de fin de grado.

El objetivo final de este proyecto será la implementación de un bot de Telegram que valiéndose de la ubicación que se le envíe devuelva locales con las características indicadas. Para esto, vamos a establecer una serie de objetivos funcionales que el bot debe cumplir:

\begin{itemize}
  \item Ser capaz de \textbf{recibir una localización y devolver una lista de locales cercanos a ella}. Estos locales deberán estar dentro de un cierto radio de distancia variable y por defecto se buscará que estén abiertos en el instante de la búsqueda.
  \item Cuando se seleccione un establecimiento, \textbf{se devolverá su ubicación} y la información de la que disponga el bot sobre él.
  \item Poderle dar una puntuación a los establecimientos y ser capaz de enviar fotografías al bot.
  \item Poder mostrar un \textbf{mapa de calor} en torno a tu localización reflejando las ubicaciones más concurridas por otros usuarios
\end{itemize}


\section{Estructura del documento}
Vamos a estructurar este documento conforme al orden en el que fuímos desarrollando el bot. Para cada versión con nuevas funcionalidades, documentaremos qué hemos cambiado, cómo lo hemos hecho y a qué problemas nos hemos enfrentado.

A continuación mostramos sobre qué va a tratar cada capítulo:

\begin{itemize}
  \item \textbf{Capítulo 2: Infraestructura para bots - Telepot}. En este capítulo introduciremos al lector al desarrollo de bots en Telegram contando cómo es la infraestructura que tienen y la API que ofrece Telegram a los desarrolladores. También hablaremos de qué es y por qué hemos usado el framework de \texttt{Telepot} para nuestro bot en vez de la API nativa de Telegram.
	
  \item \textbf{Capítulo 3: Experimentación previa}. Esta parte tratará de nuestro primer acercamiento a la creación de bots. Hablamos de cómo empezamos a usar \texttt{Telepot} para codificar bots simples y lo que aprendimos para usar en un futuro en nuestro bot final.
	
  \item \textbf{Capítulo 4: Primera versión - Establecimientos cercanos}. En este apartado hablamos sobre el desarrollo de la primera versión estable de \textbf{YourPlacesBot}. Esta versión cumple con nuestro primer objetivo que era ofrecer los establecimientos cercanos al usuario. % Versión que sólo devolvía la localización de los establecimientos. Hasta el "Here it is!" sin ninguna opción.
  \item \textbf{Capítulo 5: Segunda versión - Base de datos e interacción}. Aquí tratamos el desarrollo de la versión que ya era capaz de realizar toda la interacción entre el bot y el usuario. Es la primera versión que pusimos a funcionar de manera continuada en Telegram.
  
  \item \textbf{Capítulo 6: Tercera versión - Opciones y heatmaps}. Este capítulo trata sobre la tercera versión, donde se introducen opciones sobre el funcionamiento del bot que cada usuario puede variar y mapas de calor en base a tu ubicación.
	
	\item \textbf{Capítulo 7: Cuarta versión - Escribir direcciones y estadísticas}. Este apartado trata sobre la última versión del bot, en la cúal nuestro objetivo era mejorar y facilitar el uso del bot. Permitiendo al usuario escribir su ciudad, barrio, dirección en vez de tener que mandar la ubicación o comprobar las estadísticas de uso del bot a nivel global.
  
  \item \textbf{Capítulo 8: Conclusiones y trabajo futuro}. En este último capítulo sacamos conclusiones sobre el desarrollo del bot en Telegram y exponemos las mejoras futuras a implementar en el bot.
\end{itemize}

\newpage
\mychapter{2}{Cap\'itulo 2: Infraestructura para bots - Telepot}
%En este capítulo introduciremos al lector al desarrollo de bots en Telegram contando cómo es la infraestructura que tienen y la API que ofrece Telegram a los desarrolladores. También hablaremos de qué es y por qué hemos usado el framework de Telepot para nuestro bot en vez de la API nativa de Telegram.
Para comenzar a desarrollar un bot, hay que familiarizarse con las herramientas que ofrece Telegram para ello. Una vez entendido el funcionamiento de la plataforma de Telegram, de su API y de Telepot, estaremos listos para empezar a codificar nuestros bots.
\section{Plataforma de bots de Telegram}
El servicio de mensajería Telegram Messenger ofrece una interfaz de programación para bots, llamada Telegram Bot API. Estos bots son aplicaciones de terceros que se ejecutan en Telegram. La forma de interactuar con estos bots es muy variada: mensajes, comandos, archivos, botones, etc. Las características usuales de estos bots son proporcionar notificaciones y noticias personalizadas, juegos o integración de servicios externos a Telegram.

Los mensajes, comandos y peticiones enviados por los usuarios se envían al software que se ejecuta en los servidores. Los servidores de Telegram, que son intermediarios entre nuestro servidor y el usuario, manejan el cifrado y la comunicación. Esta comunicación se realiza a través de una interfaz HTTPS que ofrece una versión simplificada de la API de Telegram. 

Los desarrolladores deben crear sus bots a través de \texttt{@BotFather}. Este bot es el padre de todos los bots y proporciona tokens únicos para cada uno. También es necesario para administrar los bots y gestionar sus configuraciones. Además de esto, el \texttt{@BotFather} avisa a los desarrolladores de bots populares (300 solicitudes por minuto o más) si detecta que la tasa de conversión de solicitud/respuesta es muy baja. Está alerta consta de 3 botones de respuesta: Arreglado, Silenciar y Apoyo. Esta última opción abrira un nuevo chat con el \texttt{@BotSupport} que ayudará al desarrollador a detectar el problema o averiguar si hay algún problema en los servidores de Telegram.

\begin{figure}[h!]
\centering
\includegraphics[height=75mm]{tokenBotFather.jpg}
\caption{@BotFather provee los TOKEN}
\label{fig:tokenBotFather}
\end{figure}

\section{Telepot}
\texttt{Telepot} es un framework desarrollado por Nick Lee (\url{https://github.com/nickoala/telepot}) que te ayuda a desarrollar bots de Telegram usando Python. La funcionalidad básica de Telepot consiste en servir de wrapper de todas las funciones de la API de Telegram para así poder programar el código de los bots en Python. Como comentábamos en la sección anterior el uso de Telegram Bot API se realiza mediante solicitudes HTTPS a este servicio.

Además de esto, también ofrece funcionalidades para hacer más cómoda la gestión de servidor de tu bot. Cuando creas un bot, tienes que ir pidiendo a los servidores de Telegram \textit{updates} para que te envíen una lista con los mensajes que le han sido enviados. Telepot te proporciona métodos para que no tengas que preocuparte de montar toda una estructura que gestione su recepción. Telepot se encarga de crear hilos de ejecución por cada chat nuevo que se abre con el bot y de pararlos cuando estos llevan demasiado tiempo sin realizar ninguna tarea. 

\newpage
\mychapter{3}{Cap\'itulo 3: Experimentaci\'on previa}
De cara a afrontar este proyecto, nos encontramos con que debíamos aprender a hacer un bot sin tener conocimientos previos ni de la API de Telegram ni de Python. Por tanto, para coger soltura con el lenguaje y con el funcionamiento de los bots dedicamos la primera parte del proyecto a crear bots que realizasen tareas sencillas. Para crear estos bots, fuímos guiándonos del tutorial a base de ejemplos de Telepot (\url{http://telepot.readthedocs.io/en/latest/}).

\section{Creación de los bots}
El primer paso básico para crear un bot es hablar con @BotFather para crear tu bot con un nombre y que te envíe el token de tu bot. Este token es necesario para poder pedirle al servidor de Telegram las updates de tu bot. Una vez obtenido el token, hay que crear un objeto Bot con el framework de Telepot para obtener de manera periódica las updates de nuestro bot. Este proceso sería:

\lstinputlisting[language=Python, firstline=58, lastline=61]{Samples/pairingBot.py}

La clase Bot de Telepot es el wrapper principal de las funciones en HTTPS de la API de Telegram a Python. Llamando al método de message\_loop conseguimos que todos los updates nuevos los trate la función que le indiquemos por argumento, en este caso \textit{on\_chat\_message(msg)}.

Todos los mensajes que maneja el bot tienen formato JSON. Estos mensajes se envían primero a los servidores de Telegram, y son ellos los que se encargan de redirigirlos a su destino. Cuando el bot recibe los mensajes, se puede emplear la función \textit{telepot.glance(msg)} para saber qué contiene (texto, imágenes, audio,...), en qué tipo de chat se ha enviado (grupo o privado) y el id de la persona que lo envió. También se puede acceder a esta información accediendo directamente al JSON del mensaje.
\lstinputlisting[language=Python, firstline=44, lastline=53, title=Ejemplo de un on\_chat\_message]{Samples/pairingBot.py}

\section{Teclados personalizados}
En estos primeros bots también experimentamos con los distintos tipos de teclado que ofrece la API de Telegram, los \texttt{ReplyKeyboardMarkups} y los \texttt{InlineKeyboardMarkups}. La diferencia básica entre estos dos teclados es la posición que ocupan en la pantalla. El primero se sitúa fuera del propio chat sitúandose en el lugar que le correpondería al teclado QWERTY y el segundo está dentro de la propia conversación obligatoriamente acompañado de un mensaje de texto. Otra diferencia es la manera de procesar las pulsaciones, mientras las pulsaciones a los botones de los \texttt{ReplyKeyboardMarkups} se escriben automáticamente en el chat como mensaje del usuario, las pulsaciones de los botones de los \texttt{InlineKeyboardMarkups} se procesan internamente, cada vez que se pulsa uno de estos botones se crea una clase \texttt{ButtonHandler}. Estos botones se procesan como inline queries al ser pulsados, de manera que al llegar al bot se diferencian del resto de los mensajes del chat.

\begin{figure}[h!]
\centering
\begin{minipage}{7cm}
  \centering
  \includegraphics[height=40mm]{replyKB.jpg}
  \caption{ReplyKeyboardMarkup}
  \label{fig:ReplyKeyboardMarkup}
\end{minipage}%
\begin{minipage}{7cm}
  \centering
  \includegraphics[height=40mm]{inlineKB.jpg}
  \caption{InlineKeyboardMarkup}
  \label{fig:InlineKeyboardMarkups}
\end{minipage}
\end{figure}

\section{Gestión de mensajes - DelegatorBot y handlers}
Lo último con lo que hicimos pruebas en esta primera fase fue con la gestión del servidor. En un principio, nuestros bots procesaban los updates que les llegaban de manera secuencial. Cuando ya empezaron a realizar tareas más complejas, tuvimos que crear servidores simples que lanzasen un hilo por cada nuevo \textit{chat\_id} que les llegase en un mensaje. Así, el bot disponía de un diccionario con los chat\_id y una cola, para que cada mensaje proveniente de un chat\_id ya conocido se encolase para su hilo correspondiente.
\lstinputlisting[language=Python, firstline=82, lastline=87, title=Ejemplo de gestión de mensajes nuevos]{Samples/espiaBot.py}
Tras crear algunos bots que utilizaban este sistema de servidor con hilos por paso de mensajes, nos dimos cuenta de que Telepot proporciona una clase para gestionar todo esto de manera cómoda: la clase \texttt{DelegatorBot} y los \textbf{handlers}. Esta clase tiene la particularidad de que el objeto bot que creas trata de manera diferente los updates que le llegan dependiendo del tipo que sean. Además, este objeto se encarga de lanzar hilos por cada nuevo chat\_id que le llega y los tiene todos registrados por debajo en un diccionario, para poder redirigirles los mensajes que les correspondan a cada uno y poder cerrarlos cuando sea necesario.
\lstinputlisting[language=Python, firstline=323, lastline=330, title=Ejemplo de creación de un DelegatorBot]{../socialBot.py}
Para gestionar cada mensaje de una forma u otra es necesario definir un handler del tipo que corresponda: para gestionar lo relacionado con mensajes en un chat se necesita un \texttt{ChatHandler} y para tratar las pulsaciones en teclados inline se necesita un \texttt{CallbackQueryOriginHandler}. Una vez creadas las clases de los handlers, debe ponerse un \texttt{pave\_event\_space()} por cada tipo de updates diferentes que vaya a tratarse. En los argumentos de esta función se especifica qué evento genera un nuevo hilo, en el caso de ejemplo serían \texttt{per\_chat\_id()} para el ChatHandler y \texttt{per\_callback\_query\_origin()} para las pulsaciones en los teclados inline. 

El uso del \texttt{DelegatorBot} y los handlers facilita en gran medida la creación de bots más complejos. Una vez que te acomodas a los diferentes eventos de creación de hilos y de handlers que te ofrece Telepot, te ahorra el tener que gestionar tú los hilos y los mensajes, siempre y cuando comprendas bien la gestión interna de estos hilos por parte del DelegatorBot.

\newpage
\mychapter{4}{Cap\'itulo 4: Primera versi\'on - Establecimientos cercanos}
Tras la experimentación previa con Telepot y el desarrollo de varios bots básicos, comenzamos a programar el bot. Nuestro principal objetivo en esta primera versión era ofrecer los locales cercanos según la localización que nos ofrecía el usuario.

\section{Funcionalidad básica}
Al iniciar el bot, el usuario recibía un mensaje que rezaba \textit{Share your location!} a la vez que se le ofrecía un \texttt{ReplyKeyboardMarkup} con un botón que al pulsarlo compartía la localización del usuario. Después de recibir la localización, el bot continúa preguntando que tipo de establecimiento estaba buscando el usuario, dando varias opciones a través de un teclado inline. Cuando el usuario elegía que tipo de local que quería el bot le ofrecía una lista de los establecimientos de ese tipo a un radio de 500 metros. El usuario elegía entre alguno de los locales ofrecidos y el bot le mandaba la localización de este. 

\begin{figure}[h!]
\centering
\begin{minipage}{7cm}
  \centering
  \includegraphics[height=40mm]{paso1v1.jpg}
  \caption{Enviar localización}
  \label{fig:Paso1v1}
\end{minipage}%
\begin{minipage}{7cm}
  \centering
  \includegraphics[height=40mm]{paso2v1.jpg}
  \caption{Escoger tipo}
  \label{fig:Paso2v1}
\end{minipage}
\end{figure}

\section{Uso de la API de Google Maps}
Para conseguir los establecimientos en un radio de una localización concreta decidimos utilizar el cliente que proporcionan los servicios de Google Maps para Python. Utilizamos la función \texttt{places\_nearby} que al pasarle como parámetros distintos aspectos de la consulta como la localización, el radio, el tipo de local, etc. devolvía una lista en formato JSON con todos los establecimientos, y sus datos, que cumplían los parámetros establecidos. Al recibir estos datos nos encargamos de procesarlos para mostrar parte de esta información a los usuarios. 
\lstinputlisting[language=Python, firstline=148, lastline=148, title=Consulta a la API de Google Maps]{../socialBot.py}%Esta funcion es places no places_nearby
Decidimos usar los servicios prestados por Google Maps por ser la mayor aplicación a nivel mundial que ofrece las geolocalizaciones (entre otros datos) de establecimientos de ocio. Para poder utilizar estos servicios, tuvimos que registrarnos en Google Developers para obtener una clave de la API del maps de manera gratuíta. Con un límite de 1000 consultas diarias.

\begin{figure}[h!]
  \centering
  \includegraphics[height=40mm]{paso3v1.jpg}
  \caption{Escoger local}
  \label{fig:Paso3v1}
\end{figure}

%1000 consultas diarías y posible uso de una licencia de pago para aumentarlo
\section{Limitaciones de Telepot}
%Se puede buscar otro nombre de sección
En este punto nos dimos cuenta de una de las limitaciones del los \texttt{handlers}. Al definirlos en la llamada a \texttt{DelegatorBot}, también hay que poner qué tiempo de \textit{timeout} tienen. Una vez pasado este tiempo y si el \textit{thread} de un \texttt{handler} no ha recibido ningún \textit{update}, el \texttt{DelegatorBot} para ese hilo y destruye el objeto \texttt{handler} que hubiese. Si después de esto llegase un textit{update} en el mismo chat del hilo que se paró, se crearía un nuevo objeto \texttt{handler} y se lanzaría en un nuevo hilo. Esto supone que si se declaró algún atributo privado en el \texttt{handler} este se perdió durante el \textit{timeout}, por lo que hay que tenerlo en cuenta y guardar todos los datos relevantes de los \texttt{handlers} en la función \texttt{on\_time\_out} definidas dentro de la clase del \texttt{handler} correspondiente, que es la que \texttt{DelegatorBot} llama antes de hacer el \textit{timeout}.

Otro problema que observamos era que el uso del bot iba llenando el chat de mensajes y botones. Pero queríamos conseguir que la interfaz del bot se desarrollase en un solo mensaje y así evitar también que el usuario pueda pulsar botones de manera inesperada. Para mantener el flujo de interacción con el bot por medio de botones inline utilizamos continuamente la función \texttt{editMessageText} proporcionada por Telepot. Esta función es un wrapper de la función de la API de Telegram que permite editar un mensaje enviado anteriormente y cambiar su texto y el teclado que proporciona.
\lstinputlisting[language=Python, firstline=96, lastline=96, title=Edición de mensajes previos]{Samples/3rayaBot.py}

%tal vez una imagen de un chat con botones sin eliminar frente a uno con ellos eliminados

\newpage
\mychapter{5}{Cap\'itulo 5: Segunda versi\'on - Base de datos e interacci\'on}
A medida que íbamos desarrollando el bot nos encontrabamos con los primeros problemas, observabamos la necesidad de almacenar los datos y además queríamos mejorar la interacción con el bot para poder establecer un \textit{feedback} con los usuarios.

\section{MongoDB}
Como indicabamos en el capítulo anterior el uso del \texttt{DelegatorBot} tenía el inconveniente de perder los atributos privados si no hay actualizaciones en un período determinado. Además queríamos guardar datos como las localizaciones que nos enviaba el usuario para utilizarlos en funcionalidades posteriores. Ante esta coyuntura decidimos crear una base de datos para el bot, algo indispensable en casi cualquier aplicación. La problemática con la que nos encontrábamos era si utilizar una base de datos relacional o no. Nuestra decisión final fue utilizar \textbf{MongoDB}, porque nos ofrecía la capacidad de almacenar nuestros datos que no tenían la misma estructura, pero si parecida, de una manera cómoda. Además nos permitía una futura escalabilidad de esas semi-estructuras que sabíamos que íbamos a necesitar con las futuras funcionalidades del bot. 

Para gestionar la base de datos con el bot implementamos un nuevo módulo utilizando \texttt{pymongo}, que es una librería de Python que ayuda a gestionar las bases de datos con \textbf{MongoDB}. Dentro de la nueva base de datos establecimos dos colecciones, una de usuarios y otra de establecimientos. Estas dos colecciones no implementan funciones \textit{join}, dado que en MongoDB y en NoSQL en general son muy lentas. El bot cuando quiere guardar datos o extraerlos de la base de datos llama a una función específica del nuevo módulo, y este se encargará de conectar con la base de datos para extraer o persistir los datos. Para solucionar el problema del timeout, cuando este período de tiempo transcurre invocamos al método \texttt{on\_close} que persiste los atributos que van a expirar en la base de datos.

\section{Interacción con el usuario}
Llegados a este punto, aumentamos la funcionalidad del bot para que una vez que te enviase la localización de algún local y también te diese más opciones a realizar con ella. Pusimos la posibilidad de darle una valoración al local que se haya seleccionado, de cero a cinco estrellas, que también se muestra a la hora de enseñarte los locales cercanos a tí. Introducimos también la posibilidad de mandar imágenes de los locales, de forma que si un local tiene imágenes en la base de datos damos la opción de ir viéndolas a través de la interfaz con botones.

\begin{figure}[h!]
  \centering
  \includegraphics[height=40mm]{interaccionv2.jpg}
  \caption{El usuario puede valorar y ver o envíar fotos}
  \label{fig:interaccionv2}
\end{figure}

Cuando se le envía una imágen al bot, este recibe un JSON como si se tratase de un mensaje normal, pero una de las claves contiene el id que Telegram le da a la imagen. Es posible descargar el archivo de la imagen si se desea, pero con tener esta clave se puede reenviar y se recibirá como una imagen normal. De este modo, sólo es necesario guardar el id de las imágenes que se reciben en el documento de su local correspondiente. Usar MongoDB viene bien es este caso para poder guardar dentro de una misma colección documentos con distintas claves, ya que puede haber locales que no tengan puntuación o imágenes mientras que otros sí.

También para mejorar y dar más información sobre los locales a los usuarios, les proporcionamos la distancia a la que están respecto a su posición actual. Para calcularla utilizamos la fórmula del \textbf{haversine} que es una ecuación que calcula la distancia entre dos puntos de un globo sabiendo su longitud y su latitud. Esta función es sólo una aproximación, porque la Tierra no es una esfera perfecta, sino que su radio varía ascendentemente desde los polos hasta el ecuador debido a la forma geoidal del planeta. Como radio utilizamos la media geométrica, 6.367,45 kilómetros.

\begin{figure}[h!]
\centering
  \centering
  \includegraphics[width=80mm]{hav.png}
  \caption{Fórmula de haversine desarrollada para calcular la distancia}
  \label{fig:hav}
\end{figure} 

\section{Steps}
Como ahora el bot dispone de más opciones para interactuar con él, también debía disponer de un botón en su interfaz para volver atrás. Como el flujo del bot se desarrolla parecido a una máquina de estados, creamos un módulo \textit{steps} para definir los diferentes estados en los que puede encontrarse el bot, y así saber en cada momento a dónde debe ir en caso de recibir un textit{update} o de querer volver atrás. Estos estados ayudan también en el caso del timeout, ya que en la función \texttt{on\_close} se puede guardar en la base de datos el estado en el que se quedó un usuario, y cuando vuelva pueda continuar usando el bot desde el punto en el que lo dejó. Ahora que disponemos de base de datos, todas las variables locales que utiliza el handler también se pueden guardar en caso de \textit{timeout}.

\begin{figure}[h!]
  \centering
  \includegraphics[height=50mm]{steps.png}
  \caption{Estados posibles del bot}
  \label{fig:Estados posibles del bot}
\end{figure}

\section{Otros cambios}
Tras diversas comprobaciones del funcionamiento del bot, observamos que los establecimientos que nos enviaba el método \texttt{places\_nearby} no coincidía totalmente con los locales que mostraba Google Maps. Esta consulta no devolvía todos los locales cercanos, sino sólo algunos. Por lo que en su lugar comenzamos a usar el método \texttt{places} de la misma API, que realiza una búsqueda más exhaustiva. Pasándole por parámetro campos como la localización actual, el radio de la consulta o el tipo de establecimiento que el usuario está buscando. 
\lstinputlisting[language=Python, firstline=148, lastline=148, title=Consulta a la API de Google Maps]{../socialBot.py}

% Código de un on_close?
% Mencionar las imagenes en el texto?¿

\newpage
\mychapter{6}{Cap\'itulo 6: Tercera versi\'on - Opciones y Heatmaps}
Durante un tiempo estuvimos preparando el bot para que tuviese varios parámetros ajustables en cuanto a su funcionalidad. La API de Google Maps permite cambiar opciones de búsqueda como el radio de distancia, buscar sólo establecimientos abiertos o buscar establecimientos dentro de un rango de precios. También podíamos poner el bot tanto en español como en inglés. Juntando todo esto, podíamos crear un nuevo menú el en bot donde cada usuario pudiese cambiar estas opciones si lo desea y después lo persistimos en la base de datos.

\begin{figure}[h!]
  \centering
  \includegraphics[height=50mm]{settings.jpg}
  \caption{Menú de ajustes}
  \label{fig:settings}
\end{figure}

\section{Idiomas}
Para tener el texto del bot en varios idiomas creamos un nuevo módulo que contiene todos los mensajes de texto y botones que puede enviar el bot. A la hora de enviar un mensaje por el bot, para introducir el texto se hace una llamada a la función correspondiente de este módulo y se le pasa por parámetro una variable que determina si el texto se devolverá en inglés o en español. Por defecto, el bot enviará los mensajes en inglés y podrá cambiarse desde las opciones a español. Para añadir nuevos idiomas al bot, habría que traducir los métodos dentro del módulo \textit{translate.py} y añadir la opción con el nuevo idioma en las opciones del bot. De este modo resulta cómodo poder añadir nuevos idiomas al bot.

\begin{figure}[h!]
\centering
\begin{minipage}{7cm}
  \centering
  \includegraphics[height=40mm]{elegirIdioma.png}
  \caption{Elegir idioma}
  \label{fig:elegIdiom}
\end{minipage}%
\begin{minipage}{7cm}
  \centering
  \includegraphics[height=40mm]{esp.png}
  \caption{Tras cambiar a español}
  \label{fig:esi}
\end{minipage}
\end{figure}

\section{Opciones}
De los parámetros variables de la función \texttt{places}, al final dejamos el radio de búsqueda, el número de establecimientos que se muestran en una búsqueda y buscar sólo establecimientos abiertos en el momento. 

\begin{figure}[h!]
  \centering
  \includegraphics[height=50mm]{parametros.png}
  \caption{Opciones variables del bot}
  \label{fig:parametros}
\end{figure}

La opción de buscar establecimientos según un rango de precios de 0 a 4 daba resultados inesperados cuando la estuvimos probando. Al usar esta opción a veces no mostraba casi ningún establecimiento a pesar de ponerle que buscase en todo el rango, de 0 a 4. Suponemos que esto se debe a que algunos establecimientos no tienen información acerca del rango de precios en el que están, y por tanto no aparecían en búsquedas que usasen ese parámetro. Por tanto, dado que resultó ser menos útil de lo esperado, decidimos no añadir esta opción al bot.


\section{Heatmaps}
El cambio más grande de funcionalidad que introdujimos en esta versión fue la capacidad de envíar mapas de calor al usuario. Para recibirlo el usuario debe introducir el comando \texttt{/heatmap}, y el bot generará y enviará una imagen con un mapa de calor, cuyo centro es la última localización guardada del usuario que hace la petición. En este mapa de calor se muestran las zonas con más concurrencia cerca del usuario, usando las localizaciones de todos los usuarios.

Para realizar los mapas utilizamos el paquete de Python \texttt{Basemap}, que es una librería para trazar mapas 2D. Permite trazar contornos, imágenes, vectores, líneas o puntos en las coordenadas que se le proporcionen. Para construir el mapa es necesario proporcionarle a la librería los puntos geográficos que corresponden con la esquina inferior izquierda y la esquina superior derecha. Para calcular estos límites, teniendo en cuenta que conocemos el centro de la imagen, utilizamos la fórmula de haversine pero a la inversa. Si recapítulamos, recordamos que utilizabamos haversine para calcular la distancia entre dos puntos en un globo. Nosotros en este caso conocemos uno de los puntos, el ángulo y la distancia, por tanto si despejamos nuestra nueva incógnita tenemos como resultado, lo siguiente:
 
\lstinputlisting[language=Python, firstline=56, lastline=57, title=Haversine inverso en Python]{../socialBot.py}

La funcionalidad básica de \texttt{Basemap} sólo ofrece mapas dibujados, lo cúal no nos interesa porque queríamos mayor precisión a nivel ciudad o incluso barrio. Pero sí ofrece la posibilidad de sustituir estos dibujos por otras imagénes. Índicando un código EPSG, acrónimo de \textit{European Petroleum Survey Group}, que indican sistemas de referencia de coordenadas. En nuestro caso usamos el código 4326 
que indica el sistema \textit{World Geodetic System 1984} en el que está proyectado todo el planeta. Este sistema es usado por los GPS y por sistemas militares desarrollados por la OTAN. Y para obtener las imágenes vía satélite utilizamos el servicio \textit{ArcGIS}, de ESRI, en concreto el \textit{World Imagery} que tiene 24 niveles de resolución y imágenes en alta definición de casi todo el planeta.

\lstinputlisting[language=Python, firstline=79, lastline=80, title=Consultas a Basemap y a ArcGIS]{../socialBot.py}

%img de heatmap
\newpage
\mychapter{7}{Cap\'itulo 7: Cuarta versión - Escribir direcciones y estadísticas}
\newpage
\mychapter{8}{Cap\'itulo 8: Conclusiones y trabajo futuro}

\newpage
\mychapter{0}{Ap\'endice}

\newpage
\begin{thebibliography}{}
%Falta escribirlo en formato IEEE
\bibitem
*LaTex -> http://texdoc.net/texmf-dist/doc/latex/memoir/memman.pdf 
\bibitem
*Python -> https://docs.python.org/2.7/
\bibitem
*API Google Maps Docs -> http://googlemaps.github.io/google-maps-services-python/docs/2.4.5/
\bibitem
*Telegram Bots -> https://core.telegram.org/bots/api
\bibitem
*API Telepot -> http://telepot.readthedocs.io/en/latest/
\end{thebibliography}

\newpage
\mychapter{0}{Anexo}

\newpage
\mychapter{0}{Glosario}

\end{document}